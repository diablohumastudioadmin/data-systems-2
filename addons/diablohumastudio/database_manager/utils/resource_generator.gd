@tool
class_name ResourceGenerator
extends RefCounted

## Generates GDScript Resource classes from DataTypeDefinition
## Creates .gd files that can be used as custom Resource types in inspector

const BASE_RESOURCES_PATH = "res://addons/diablohumastudio/database_manager/table_structures/"


## Generate Resource class file from definition
static func generate_resource_class(definition: DataTypeDefinition) -> Error:
	var file_path = _get_resource_file_path(definition.type_name)

	# Generate GDScript code
	var script_content = _generate_script_content(definition)

	# Ensure directory exists
	var error = JSONPersistence.ensure_directory(BASE_RESOURCES_PATH)
	if error != OK:
		push_error("Failed to create resources directory")
		return error

	# Write file
	var file = FileAccess.open(file_path, FileAccess.WRITE)
	if file == null:
		error = FileAccess.get_open_error()
		push_error("Failed to create resource file: %s (Error: %d)" % [file_path, error])
		return error

	file.store_string(script_content)
	file.close()

	print("[ResourceGenerator] Generated: %s" % file_path)
	return OK


## Generate script content from definition
static func _generate_script_content(definition: DataTypeDefinition) -> String:
	var lines: Array[String] = []

	# Header
	lines.append("@tool")
	lines.append("class_name %s" % definition.type_name)
	lines.append("extends DataItem")
	lines.append("")
	lines.append("## Auto-generated DataItem subclass for %s data type" % definition.type_name)
	lines.append("## Generated by Data Systems Plugin")
	lines.append("")

	# Properties
	for prop in definition.properties:
		var type_str = _get_gdscript_type(prop.type)
		var default_str = _get_default_value_string(prop.default, prop.type)

		# Add export annotation
		lines.append("@export var %s: %s = %s" % [prop.name, type_str, default_str])

	lines.append("")

	# Constructor (optional, for initialization)
	lines.append("func _init() -> void:")
	lines.append("\tpass")
	lines.append("")

	# Override get_type_name() from DataItem
	lines.append("## Returns the schema name for this data type")
	lines.append("func get_type_name() -> String:")
	lines.append("\treturn \"%s\"" % definition.type_name)
	lines.append("")

	# Helper method to convert to dictionary (useful for serialization)
	lines.append("## Convert to dictionary for serialization")
	lines.append("func to_dict() -> Dictionary:")
	lines.append("\treturn {")
	for i in range(definition.properties.size()):
		var prop = definition.properties[i]
		var comma = "," if i < definition.properties.size() - 1 else ""
		lines.append("\t\t\"%s\": %s%s" % [prop.name, prop.name, comma])
	lines.append("\t}")
	lines.append("")

	# Helper method to load from dictionary
	lines.append("## Load from dictionary")
	lines.append("func from_dict(data: Dictionary) -> void:")
	for prop in definition.properties:
		var type_str = _get_gdscript_type(prop.type)
		lines.append("\tif data.has(\"%s\"):" % prop.name)
		lines.append("\t\t%s = data[\"%s\"]" % [prop.name, prop.name])
	lines.append("")

	return "\n".join(lines)


## Get GDScript type string
static func _get_gdscript_type(prop_type: DataTypeDefinition.PropertyType) -> String:
	match prop_type:
		DataTypeDefinition.PropertyType.INT:
			return "int"
		DataTypeDefinition.PropertyType.FLOAT:
			return "float"
		DataTypeDefinition.PropertyType.STRING:
			return "String"
		DataTypeDefinition.PropertyType.BOOL:
			return "bool"
		DataTypeDefinition.PropertyType.TEXTURE2D:
			return "Texture2D"
		DataTypeDefinition.PropertyType.VECTOR2:
			return "Vector2"
		DataTypeDefinition.PropertyType.VECTOR3:
			return "Vector3"
		DataTypeDefinition.PropertyType.COLOR:
			return "Color"
		DataTypeDefinition.PropertyType.ARRAY:
			return "Array"
		DataTypeDefinition.PropertyType.DICTIONARY:
			return "Dictionary"
		_:
			return "Variant"


## Get default value as GDScript string
static func _get_default_value_string(value: Variant, prop_type: DataTypeDefinition.PropertyType) -> String:
	match prop_type:
		DataTypeDefinition.PropertyType.INT:
			return str(value if value != null else 0)
		DataTypeDefinition.PropertyType.FLOAT:
			return str(value if value != null else 0.0)
		DataTypeDefinition.PropertyType.STRING:
			return '"%s"' % (value if value != null else "")
		DataTypeDefinition.PropertyType.BOOL:
			return "true" if value else "false"
		DataTypeDefinition.PropertyType.TEXTURE2D:
			if value is Texture2D and !value.resource_path.is_empty():
				return 'preload("%s")' % value.resource_path
			return "null"
		DataTypeDefinition.PropertyType.VECTOR2:
			if value is Vector2:
				return "Vector2(%f, %f)" % [value.x, value.y]
			return "Vector2.ZERO"
		DataTypeDefinition.PropertyType.VECTOR3:
			if value is Vector3:
				return "Vector3(%f, %f, %f)" % [value.x, value.y, value.z]
			return "Vector3.ZERO"
		DataTypeDefinition.PropertyType.COLOR:
			if value is Color:
				return 'Color("%s")' % value.to_html()
			return "Color.WHITE"
		DataTypeDefinition.PropertyType.ARRAY:
			return "[]"
		DataTypeDefinition.PropertyType.DICTIONARY:
			return "{}"
		_:
			return "null"


## Get resource file path for a type
static func _get_resource_file_path(type_name: String) -> String:
	return BASE_RESOURCES_PATH.path_join(type_name.to_lower() + ".gd")


## Check if resource class exists
static func resource_exists(type_name: String) -> bool:
	return FileAccess.file_exists(_get_resource_file_path(type_name))


## Delete resource class file
static func delete_resource_class(type_name: String) -> Error:
	var file_path = _get_resource_file_path(type_name)

	if !FileAccess.file_exists(file_path):
		return ERR_FILE_NOT_FOUND

	var dir = DirAccess.open(BASE_RESOURCES_PATH)
	if dir == null:
		return DirAccess.get_open_error()

	return dir.remove(file_path.get_file())


## Regenerate all resource classes from definitions
static func regenerate_all_resources(definitions: Array[DataTypeDefinition]) -> int:
	var count = 0
	for definition in definitions:
		if !definition.is_user_data:  # Only generate for master data types
			if generate_resource_class(definition) == OK:
				count += 1

	print("[ResourceGenerator] Regenerated %d resource classes" % count)
	return count
