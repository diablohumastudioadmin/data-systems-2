@tool
class_name ResourceGenerator
extends RefCounted

## Generates GDScript Resource classes (table structures) and enum ID files.
## Creates .gd files that serve as both schema definitions and typed DataItem subclasses.

const DEFAULT_STRUCTURES_PATH = "res://database/res/table_structures/"
const DEFAULT_IDS_PATH = "res://database/res/ids/"

## Field types supported by the system
enum FieldType {
	INT, FLOAT, STRING, BOOL, TEXTURE2D,
	VECTOR2, VECTOR3, COLOR, ARRAY, DICTIONARY,
	TYPED_ARRAY, TYPED_DICTIONARY
}

const TYPE_DEFAULTS = {
	FieldType.INT: 0,
	FieldType.FLOAT: 0.0,
	FieldType.STRING: "",
	FieldType.BOOL: false,
	FieldType.TEXTURE2D: null,
	FieldType.VECTOR2: Vector2.ZERO,
	FieldType.VECTOR3: Vector3.ZERO,
	FieldType.COLOR: Color.WHITE,
	FieldType.ARRAY: [],
	FieldType.DICTIONARY: {},
	FieldType.TYPED_ARRAY: [],
	FieldType.TYPED_DICTIONARY: {}
}


# --- Resource Class Generation -----------------------------------------------

## Generate Resource class file from table name and fields
## fields: Array of {name: String, type: FieldType, default: Variant}
static func generate_resource_class(table_name: String, fields: Array[Dictionary], base_path: String = DEFAULT_STRUCTURES_PATH) -> Error:
	var file_path = base_path.path_join(table_name.to_lower() + ".gd")
	var script_content = _generate_script_content(table_name, fields)

	var error = _ensure_directory(base_path)
	if error != OK:
		push_error("Failed to create resources directory")
		return error

	var file = FileAccess.open(file_path, FileAccess.WRITE)
	if file == null:
		error = FileAccess.get_open_error()
		push_error("Failed to create resource file: %s (Error: %d)" % [file_path, error])
		return error

	file.store_string(script_content)
	file.close()

	print("[ResourceGenerator] Generated: %s" % file_path)
	return OK


## Delete resource class file
static func delete_resource_class(table_name: String, base_path: String = DEFAULT_STRUCTURES_PATH) -> Error:
	var file_path = base_path.path_join(table_name.to_lower() + ".gd")
	if !FileAccess.file_exists(file_path):
		return ERR_FILE_NOT_FOUND
	var dir = DirAccess.open(base_path)
	if dir == null:
		return DirAccess.get_open_error()
	return dir.remove(file_path.get_file())


## Check if resource class exists
static func resource_exists(table_name: String, base_path: String = DEFAULT_STRUCTURES_PATH) -> bool:
	return FileAccess.file_exists(base_path.path_join(table_name.to_lower() + ".gd"))


## Regenerate all resource classes
static func regenerate_all(table_data: Array[Dictionary], base_path: String = DEFAULT_STRUCTURES_PATH) -> int:
	var count = 0
	for entry in table_data:
		if generate_resource_class(entry.table_name, entry.fields, base_path) == OK:
			count += 1
	print("[ResourceGenerator] Regenerated %d resource classes" % count)
	return count


# --- Enum ID File Generation -------------------------------------------------

## Generate an enum .gd file for a table's instances.
## Only includes instances that have a non-empty `name` property.
static func generate_enum_file(table_name: String, instances: Array[DataItem], base_path: String = DEFAULT_IDS_PATH) -> Error:
	var error = _ensure_directory(base_path)
	if error != OK:
		push_error("Failed to create ids directory")
		return error

	var file_path = base_path.path_join(table_name.to_lower() + "_ids.gd")
	var content = _generate_enum_content(table_name, instances)

	var file = FileAccess.open(file_path, FileAccess.WRITE)
	if file == null:
		error = FileAccess.get_open_error()
		push_error("Failed to create enum file: %s (Error: %d)" % [file_path, error])
		return error

	file.store_string(content)
	file.close()

	print("[ResourceGenerator] Generated enum: %s" % file_path)
	return OK


## Delete enum file for a table
static func delete_enum_file(table_name: String, base_path: String = DEFAULT_IDS_PATH) -> Error:
	var file_path = base_path.path_join(table_name.to_lower() + "_ids.gd")
	if !FileAccess.file_exists(file_path):
		return ERR_FILE_NOT_FOUND
	var dir = DirAccess.open(base_path)
	if dir == null:
		return DirAccess.get_open_error()
	return dir.remove(file_path.get_file())


static func _generate_enum_content(table_name: String, instances: Array[DataItem]) -> String:
	var class_name_str = "%sIds" % table_name
	var lines: Array[String] = []

	lines.append("class_name %s" % class_name_str)
	lines.append("")
	lines.append("## Auto-generated by DatabaseManager — do not edit manually")
	lines.append("")
	lines.append("enum Id {")

	var entries: Array[String] = []
	for item in instances:
		if item.name.is_empty():
			continue
		var key = _sanitize_enum_key(item.name)
		if key.is_empty():
			continue
		entries.append("\t%s = %d," % [key, item.id])

	for entry in entries:
		lines.append(entry)

	lines.append("}")
	lines.append("")
	return "\n".join(lines)


## Convert a human-readable name to a valid GDScript enum key
## "Forest Level" → "FOREST_LEVEL", "my-item" → "MY_ITEM"
static func _sanitize_enum_key(name_str: String) -> String:
	var result = name_str.strip_edges().to_upper()
	# Replace spaces, hyphens, dots with underscores
	result = result.replace(" ", "_")
	result = result.replace("-", "_")
	result = result.replace(".", "_")
	# Remove any character that's not alphanumeric or underscore
	var sanitized := ""
	for i in range(result.length()):
		var c = result[i]
		if c == "_" or (c >= "A" and c <= "Z") or (c >= "0" and c <= "9"):
			sanitized += c
	# Ensure it doesn't start with a digit
	if sanitized.length() > 0 and sanitized[0] >= "0" and sanitized[0] <= "9":
		sanitized = "_" + sanitized
	# Collapse multiple underscores
	while sanitized.contains("__"):
		sanitized = sanitized.replace("__", "_")
	return sanitized


# --- Script Content Generation -----------------------------------------------

static func _generate_script_content(table_name: String, fields: Array[Dictionary]) -> String:
	var lines: Array[String] = []

	lines.append("@tool")
	lines.append("class_name %s" % table_name)
	lines.append("extends DataItem")
	lines.append("")
	lines.append("## Auto-generated DataItem subclass for %s table" % table_name)
	lines.append("## Generated by Data Systems Plugin — do not edit manually")
	lines.append("")

	for field in fields:
		var type_str = _get_gdscript_type_for_field(field)
		var default_str = _get_default_value_string(field.get("default"), field.type)
		lines.append("@export var %s: %s = %s" % [field.name, type_str, default_str])

	lines.append("")
	return "\n".join(lines)


## Convert Variant.Type (from script reflection) back to FieldType
## field_info: Dictionary from get_script_property_list()
static func variant_type_to_field_type(field_info: Dictionary) -> FieldType:
	match field_info.type:
		TYPE_INT:
			return FieldType.INT
		TYPE_FLOAT:
			return FieldType.FLOAT
		TYPE_STRING:
			return FieldType.STRING
		TYPE_BOOL:
			return FieldType.BOOL
		TYPE_OBJECT:
			var cls = field_info.get("class_name", "")
			if cls == &"Texture2D" or field_info.get("hint_string", "") == "Texture2D":
				return FieldType.TEXTURE2D
			return FieldType.TEXTURE2D
		TYPE_VECTOR2:
			return FieldType.VECTOR2
		TYPE_VECTOR3:
			return FieldType.VECTOR3
		TYPE_COLOR:
			return FieldType.COLOR
		TYPE_ARRAY:
			if not field_info.get("hint_string", "").is_empty():
				return FieldType.TYPED_ARRAY
			return FieldType.ARRAY
		TYPE_DICTIONARY:
			if not field_info.get("hint_string", "").is_empty():
				return FieldType.TYPED_DICTIONARY
			return FieldType.DICTIONARY
		_:
			return FieldType.STRING


# --- Helpers -----------------------------------------------------------------

## Returns the GDScript type string for a field dict, handling typed arrays/dicts.
static func _get_gdscript_type_for_field(field: Dictionary) -> String:
	var ft: FieldType = field.type
	if ft == FieldType.TYPED_ARRAY:
		var et: int = field.get("element_type", -1)
		if et >= 0:
			return "Array[%s]" % _get_gdscript_type(et as FieldType)
		return "Array"
	if ft == FieldType.TYPED_DICTIONARY:
		var kt: int = field.get("key_type", -1)
		var vt: int = field.get("value_type", -1)
		if kt >= 0 and vt >= 0:
			return "Dictionary[%s, %s]" % [
				_get_gdscript_type(kt as FieldType),
				_get_gdscript_type(vt as FieldType)
			]
		return "Dictionary"
	return _get_gdscript_type(ft)


## Extract the typed array element FieldType from a reflection property info dict.
## Returns -1 if not a typed array or element type is unrecognised.
static func variant_type_to_element_type(field_info: Dictionary) -> int:
	if field_info.type != TYPE_ARRAY:
		return -1
	return _parse_hint_part(field_info.get("hint_string", ""))


## Extract the typed dictionary key FieldType from a reflection property info dict.
## hint_string format (Godot 4.4): "<TypeNum>:<Name>;<TypeNum>:<Name>" e.g. "4:String;2:int"
## Returns -1 if not a typed dictionary or key type is unrecognised.
static func variant_type_to_key_type(field_info: Dictionary) -> int:
	if field_info.type != TYPE_DICTIONARY:
		return -1
	var hs: String = field_info.get("hint_string", "")
	if not ";" in hs:
		return -1
	return _parse_hint_part(hs.split(";")[0])


## Extract the typed dictionary value FieldType from a reflection property info dict.
## Returns -1 if not a typed dictionary or value type is unrecognised.
static func variant_type_to_value_type(field_info: Dictionary) -> int:
	if field_info.type != TYPE_DICTIONARY:
		return -1
	var hs: String = field_info.get("hint_string", "")
	if not ";" in hs:
		return -1
	return _parse_hint_part(hs.split(";")[1])


## Parse "<VariantTypeNum>:<TypeName>" hint part → FieldType int, or -1.
static func _parse_hint_part(part: String) -> int:
	if part.is_empty():
		return -1
	var colon := part.find(":")
	var num_str := part.substr(0, colon if colon >= 0 else part.length())
	if not num_str.is_valid_int():
		return -1
	match int(num_str):
		TYPE_INT:     return FieldType.INT
		TYPE_FLOAT:   return FieldType.FLOAT
		TYPE_STRING:  return FieldType.STRING
		TYPE_BOOL:    return FieldType.BOOL
		TYPE_VECTOR2: return FieldType.VECTOR2
		TYPE_VECTOR3: return FieldType.VECTOR3
		TYPE_COLOR:   return FieldType.COLOR
	return -1


static func _get_gdscript_type(field_type: FieldType) -> String:
	match field_type:
		FieldType.INT: return "int"
		FieldType.FLOAT: return "float"
		FieldType.STRING: return "String"
		FieldType.BOOL: return "bool"
		FieldType.TEXTURE2D: return "Texture2D"
		FieldType.VECTOR2: return "Vector2"
		FieldType.VECTOR3: return "Vector3"
		FieldType.COLOR: return "Color"
		FieldType.ARRAY: return "Array"
		FieldType.DICTIONARY: return "Dictionary"
		FieldType.TYPED_ARRAY: return "Array"
		FieldType.TYPED_DICTIONARY: return "Dictionary"
		_: return "Variant"


static func _get_default_value_string(value: Variant, field_type: FieldType) -> String:
	match field_type:
		FieldType.INT:
			return str(value if value != null else 0)
		FieldType.FLOAT:
			return str(value if value != null else 0.0)
		FieldType.STRING:
			return '"%s"' % (value if value != null else "")
		FieldType.BOOL:
			return "true" if value else "false"
		FieldType.TEXTURE2D:
			if value is Texture2D and !value.resource_path.is_empty():
				return 'preload("%s")' % value.resource_path
			return "null"
		FieldType.VECTOR2:
			if value is Vector2:
				return "Vector2(%f, %f)" % [value.x, value.y]
			return "Vector2.ZERO"
		FieldType.VECTOR3:
			if value is Vector3:
				return "Vector3(%f, %f, %f)" % [value.x, value.y, value.z]
			return "Vector3.ZERO"
		FieldType.COLOR:
			if value is Color:
				return 'Color("%s")' % value.to_html()
			return "Color.WHITE"
		FieldType.ARRAY, FieldType.TYPED_ARRAY:
			return "[]"
		FieldType.DICTIONARY, FieldType.TYPED_DICTIONARY:
			return "{}"
		_:
			return "null"


## Ensure directory exists, creating it recursively if needed.
static func _ensure_directory(dir_path: String) -> Error:
	if DirAccess.dir_exists_absolute(dir_path):
		return OK
	return DirAccess.make_dir_recursive_absolute(dir_path)
